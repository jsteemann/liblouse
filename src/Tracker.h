
#ifndef LOUSE_TRACKER_H
#define LOUSE_TRACKER_H 1

#include <unordered_map>
#include <cstdarg>
#include <regex.h>

#include "Configuration.h"
#include "MemoryAllocation.h"
#include "Heap.h"

// -----------------------------------------------------------------------------
// --SECTION--                                                     class Tracker
// -----------------------------------------------------------------------------

namespace debugging {
  class Tracker {

// -----------------------------------------------------------------------------
// --SECTION--                                                      public types
// -----------------------------------------------------------------------------

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief tracker state
////////////////////////////////////////////////////////////////////////////////

      enum StateType {
        STATE_UNINITIALIZED,
        STATE_INITIALIZING,
        STATE_HOOKED,
        STATE_TRACING
      };

////////////////////////////////////////////////////////////////////////////////
/// @brief typedefs for malloc(), calloc(), realloc() and free()
////////////////////////////////////////////////////////////////////////////////

      typedef void* (*MallocFuncType) (size_t);
      typedef void* (*CallocFuncType) (size_t, size_t);
      typedef void* (*ReallocFuncType) (void*, size_t);
      typedef void (*FreeFuncType) (void*);

// -----------------------------------------------------------------------------
// --SECTION--                                        constructors / destructors
// -----------------------------------------------------------------------------

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief create the tracker
/// note: this may be called AFTER the first malloc/calloc!
////////////////////////////////////////////////////////////////////////////////

      Tracker ();

////////////////////////////////////////////////////////////////////////////////
/// @brief destroy the tracker
/// this performs leak checking
////////////////////////////////////////////////////////////////////////////////

      ~Tracker ();

// -----------------------------------------------------------------------------
// --SECTION--                                                    public methods
// -----------------------------------------------------------------------------

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief staticially initialize the tracker
/// this may be called by the constructor or before
////////////////////////////////////////////////////////////////////////////////

      static void Initialize ();

////////////////////////////////////////////////////////////////////////////////
/// @brief print an error and abort execution
////////////////////////////////////////////////////////////////////////////////

      static void ImmediateAbort (char const*, char const*);

////////////////////////////////////////////////////////////////////////////////
/// @brief allocate some untracked memory
////////////////////////////////////////////////////////////////////////////////

      static void* AllocateInitialMemory (size_t); 

////////////////////////////////////////////////////////////////////////////////
/// @brief free some untracked memory
////////////////////////////////////////////////////////////////////////////////

      static bool FreeInitialMemory (void*);

////////////////////////////////////////////////////////////////////////////////
/// @brief allocate memory that is going to be tracked
////////////////////////////////////////////////////////////////////////////////

      void* allocateMemory (size_t, MemoryAllocation::AccessType);

////////////////////////////////////////////////////////////////////////////////
/// @brief free tracked memory
/// this will already report errors
////////////////////////////////////////////////////////////////////////////////

      void freeMemory (void*, MemoryAllocation::AccessType);

////////////////////////////////////////////////////////////////////////////////
/// @brief get the size of a memory allocation
////////////////////////////////////////////////////////////////////////////////
 
      size_t memorySize (void*) const;

// -----------------------------------------------------------------------------
// --SECTION--                                                   private methods
// -----------------------------------------------------------------------------

    private:

////////////////////////////////////////////////////////////////////////////////
/// @brief whether or not a leak should be suppressed
////////////////////////////////////////////////////////////////////////////////
      
      bool mustSuppressLeak (char const*);

////////////////////////////////////////////////////////////////////////////////
/// @brief prints the current stacktrace
////////////////////////////////////////////////////////////////////////////////

      void emitStackTrace ();

////////////////////////////////////////////////////////////////////////////////
/// @brief prints the stacktrace for the stack argument
////////////////////////////////////////////////////////////////////////////////

      void emitStackTrace (void**);

////////////////////////////////////////////////////////////////////////////////
/// @brief print overall results for the linked list of memory blocks,
/// starting with the argument
////////////////////////////////////////////////////////////////////////////////

      void emitResults (MemoryAllocation const*);

////////////////////////////////////////////////////////////////////////////////
/// @brief print all leaks for the memory blocks, starting with the argument
////////////////////////////////////////////////////////////////////////////////

      void emitLeaks (MemoryAllocation const*); 

////////////////////////////////////////////////////////////////////////////////
/// @brief emits a line
////////////////////////////////////////////////////////////////////////////////

      static void EmitLine (char const*, ...);

////////////////////////////////////////////////////////////////////////////////
/// @brief emits an error
////////////////////////////////////////////////////////////////////////////////

      static void EmitError (char const*, char const*, ...); 

////////////////////////////////////////////////////////////////////////////////
/// @brief captures a stacktrace
////////////////////////////////////////////////////////////////////////////////

      void** captureStackTrace ();

////////////////////////////////////////////////////////////////////////////////
/// @brief converts a stacktrace into human-readable text
////////////////////////////////////////////////////////////////////////////////

      char* resolveStack (std::unordered_map<void*, char*>&, char*, size_t, void**);

////////////////////////////////////////////////////////////////////////////////
/// @brief calls addr2line 
////////////////////////////////////////////////////////////////////////////////

      char* addr2line (char const*, void*, char**);

////////////////////////////////////////////////////////////////////////////////
/// @brief determines the name of the executable
////////////////////////////////////////////////////////////////////////////////

      void determineProgname ();

////////////////////////////////////////////////////////////////////////////////
/// @brief determines the current directory
////////////////////////////////////////////////////////////////////////////////

      void determineDirectory ();

////////////////////////////////////////////////////////////////////////////////
/// @brief returns the name of the executable
////////////////////////////////////////////////////////////////////////////////

      char const* progname () const {
        return &prognameBuffer[0];
      }

// -----------------------------------------------------------------------------
// --SECTION--                                           public static variables
// -----------------------------------------------------------------------------

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief library malloc() function
////////////////////////////////////////////////////////////////////////////////

      static MallocFuncType    LibraryMalloc;

////////////////////////////////////////////////////////////////////////////////
/// @brief library calloc() function
////////////////////////////////////////////////////////////////////////////////

      static CallocFuncType    LibraryCalloc;

////////////////////////////////////////////////////////////////////////////////
/// @brief library realloc() function
////////////////////////////////////////////////////////////////////////////////

      static ReallocFuncType   LibraryRealloc;

////////////////////////////////////////////////////////////////////////////////
/// @brief library free() function
////////////////////////////////////////////////////////////////////////////////

      static FreeFuncType      LibraryFree;

////////////////////////////////////////////////////////////////////////////////
/// @brief tracker state
////////////////////////////////////////////////////////////////////////////////

      static StateType         State;

////////////////////////////////////////////////////////////////////////////////
/// @brief output stream
////////////////////////////////////////////////////////////////////////////////

      static FILE*             OutFile;

////////////////////////////////////////////////////////////////////////////////
/// @brief configuration
////////////////////////////////////////////////////////////////////////////////

      static Configuration     Config;

// -----------------------------------------------------------------------------
// --SECTION--                                                 private variables
// -----------------------------------------------------------------------------

    private:

////////////////////////////////////////////////////////////////////////////////
/// @brief the heap
////////////////////////////////////////////////////////////////////////////////

      Heap                     allocations;

////////////////////////////////////////////////////////////////////////////////
/// @brief buffer for executable name
////////////////////////////////////////////////////////////////////////////////

      char                     prognameBuffer[512];

////////////////////////////////////////////////////////////////////////////////
/// @brief buffer for directory name
////////////////////////////////////////////////////////////////////////////////

      char                     directoryBuffer[512];

////////////////////////////////////////////////////////////////////////////////
/// @brief length of directory name
////////////////////////////////////////////////////////////////////////////////

      size_t                   directoryLength;

////////////////////////////////////////////////////////////////////////////////
/// @brief compiled regex for filtering leaks
////////////////////////////////////////////////////////////////////////////////

      regex_t                  leakRegex;

////////////////////////////////////////////////////////////////////////////////
/// @brief buffer for untracked pointers
////////////////////////////////////////////////////////////////////////////////

      static void*             UntrackedPointers[4096];

////////////////////////////////////////////////////////////////////////////////
/// @brief length of untracked pointers buffer
////////////////////////////////////////////////////////////////////////////////

      static size_t            UntrackedPointersLength;
  };
}

#endif
