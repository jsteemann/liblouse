
#ifndef LOUSE_TRACKER_H
#define LOUSE_TRACKER_H 1

#include <regex.h>

#include "Configuration.h"
#include "MemoryAllocation.h"
#include "Heap.h"

// -----------------------------------------------------------------------------
// --SECTION--                                                     class Tracker
// -----------------------------------------------------------------------------

namespace debugging {
  class Tracker {

// -----------------------------------------------------------------------------
// --SECTION--                                                      public types
// -----------------------------------------------------------------------------

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief tracker state
////////////////////////////////////////////////////////////////////////////////

      enum StateType {
        STATE_UNINITIALIZED,
        STATE_INITIALIZING,
        STATE_HOOKED,
        STATE_TRACING
      };

////////////////////////////////////////////////////////////////////////////////
/// @brief typedefs for malloc(), calloc(), realloc() and free()
////////////////////////////////////////////////////////////////////////////////

      typedef void* (*MallocFuncType) (size_t);
      typedef void* (*CallocFuncType) (size_t, size_t);
      typedef void* (*ReallocFuncType) (void*, size_t);
      typedef void (*FreeFuncType) (void*);
      typedef void (*ExitFuncType) (int) __attribute__ ((noreturn));

// -----------------------------------------------------------------------------
// --SECTION--                                        constructors / destructors
// -----------------------------------------------------------------------------

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief create the tracker
/// note: this may be called AFTER the first malloc/calloc!
////////////////////////////////////////////////////////////////////////////////

      Tracker ();

////////////////////////////////////////////////////////////////////////////////
/// @brief destroy the tracker
/// this performs leak checking
////////////////////////////////////////////////////////////////////////////////

      ~Tracker ();

// -----------------------------------------------------------------------------
// --SECTION--                                                    public methods
// -----------------------------------------------------------------------------

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief staticially initialize the tracker
/// this may be called by the constructor or before
////////////////////////////////////////////////////////////////////////////////

      static void Initialize ();

////////////////////////////////////////////////////////////////////////////////
/// @brief staticially shut down the tracker
/// this may be called by the destructor or otherwise
////////////////////////////////////////////////////////////////////////////////

      static void Shutdown ();

////////////////////////////////////////////////////////////////////////////////
/// @brief terminate the execution
////////////////////////////////////////////////////////////////////////////////

      static void Exit (int, bool) __attribute__ ((noreturn));

////////////////////////////////////////////////////////////////////////////////
/// @brief print an error and abort execution
////////////////////////////////////////////////////////////////////////////////

      static void ImmediateAbort (char const*, char const*);

////////////////////////////////////////////////////////////////////////////////
/// @brief allocate some untracked memory
////////////////////////////////////////////////////////////////////////////////

      static void* AllocateInitialMemory (size_t); 

////////////////////////////////////////////////////////////////////////////////
/// @brief free some untracked memory
////////////////////////////////////////////////////////////////////////////////

      static bool FreeInitialMemory (void*);

////////////////////////////////////////////////////////////////////////////////
/// @brief allocate memory that is going to be tracked
////////////////////////////////////////////////////////////////////////////////

      void* allocateMemory (size_t, MemoryAllocation::AccessType);

////////////////////////////////////////////////////////////////////////////////
/// @brief free tracked memory
/// this will already report errors
////////////////////////////////////////////////////////////////////////////////

      void freeMemory (void*, MemoryAllocation::AccessType);

////////////////////////////////////////////////////////////////////////////////
/// @brief get the size of a memory allocation
////////////////////////////////////////////////////////////////////////////////
 
      size_t memorySize (void*) const;

////////////////////////////////////////////////////////////////////////////////
/// @brief finalize the tracker, show results
////////////////////////////////////////////////////////////////////////////////

      void finalize ();

// -----------------------------------------------------------------------------
// --SECTION--                                                   private methods
// -----------------------------------------------------------------------------

    private:

////////////////////////////////////////////////////////////////////////////////
/// @brief whether or not a leak should be suppressed
////////////////////////////////////////////////////////////////////////////////
      
      bool mustSuppressLeak (char const*, regex_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief prints the current stacktrace
////////////////////////////////////////////////////////////////////////////////

      void emitStackTrace ();

////////////////////////////////////////////////////////////////////////////////
/// @brief prints the stacktrace for the stack argument
////////////////////////////////////////////////////////////////////////////////

      void emitStackTrace (void**);

////////////////////////////////////////////////////////////////////////////////
/// @brief print overall results for the linked list of memory blocks,
/// starting with the argument
////////////////////////////////////////////////////////////////////////////////

      void emitResults (regex_t*);

////////////////////////////////////////////////////////////////////////////////
/// @brief print all leaks for the memory blocks, starting with the argument
////////////////////////////////////////////////////////////////////////////////

      void emitLeaks (MemoryAllocation const*, regex_t*); 

// -----------------------------------------------------------------------------
// --SECTION--                                           public static variables
// -----------------------------------------------------------------------------

    public:

////////////////////////////////////////////////////////////////////////////////
/// @brief library malloc() function
////////////////////////////////////////////////////////////////////////////////

      static MallocFuncType    LibraryMalloc;

////////////////////////////////////////////////////////////////////////////////
/// @brief library calloc() function
////////////////////////////////////////////////////////////////////////////////

      static CallocFuncType    LibraryCalloc;

////////////////////////////////////////////////////////////////////////////////
/// @brief library realloc() function
////////////////////////////////////////////////////////////////////////////////

      static ReallocFuncType   LibraryRealloc;

////////////////////////////////////////////////////////////////////////////////
/// @brief library free() function
////////////////////////////////////////////////////////////////////////////////

      static FreeFuncType      LibraryFree;

////////////////////////////////////////////////////////////////////////////////
/// @brief library exit() function
////////////////////////////////////////////////////////////////////////////////

      static ExitFuncType      LibraryExit;

////////////////////////////////////////////////////////////////////////////////
/// @brief library _exit() function
////////////////////////////////////////////////////////////////////////////////

      static ExitFuncType      Library_Exit;

////////////////////////////////////////////////////////////////////////////////
/// @brief tracker state
////////////////////////////////////////////////////////////////////////////////

      static StateType         State;

////////////////////////////////////////////////////////////////////////////////
/// @brief output stream
////////////////////////////////////////////////////////////////////////////////

      static FILE*             OutFile;

////////////////////////////////////////////////////////////////////////////////
/// @brief configuration
////////////////////////////////////////////////////////////////////////////////

      static Configuration     Config;

////////////////////////////////////////////////////////////////////////////////
/// @brief whether or not finalization was run
////////////////////////////////////////////////////////////////////////////////

      static bool              Finalized;

// -----------------------------------------------------------------------------
// --SECTION--                                                 private variables
// -----------------------------------------------------------------------------

    private:

////////////////////////////////////////////////////////////////////////////////
/// @brief the heap
////////////////////////////////////////////////////////////////////////////////

      Heap                     heap_;

////////////////////////////////////////////////////////////////////////////////
/// @brief buffer for untracked pointers
////////////////////////////////////////////////////////////////////////////////

      static void*             UntrackedPointers[4096];

////////////////////////////////////////////////////////////////////////////////
/// @brief length of untracked pointers buffer
////////////////////////////////////////////////////////////////////////////////

      static size_t            UntrackedPointersLength;
  };
}

#endif
